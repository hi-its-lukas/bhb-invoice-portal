import {
  portalCustomers,
  portalUserCustomers,
  bhbReceiptsCache,
  dunningRules,
  dunningEvents,
  users,
  portalSettings,
  counterpartyMappings,
  type PortalCustomer,
  type InsertPortalCustomer,
  type PortalUserCustomer,
  type InsertPortalUserCustomer,
  type BhbReceiptsCache,
  type InsertBhbReceiptsCache,
  type DunningRules,
  type InsertDunningRules,
  type DunningEvent,
  type InsertDunningEvent,
  type User,
  type InsertUser,
  type PortalSetting,
  type CounterpartyMapping,
  type InsertCounterpartyMapping,
} from "@shared/schema";
import { db } from "./db";
import { eq, and, desc, sql, lte, isNull, or } from "drizzle-orm";
import bcrypt from "bcryptjs";
import { encrypt, decrypt, isEncrypted } from "./crypto";

const SENSITIVE_SETTINGS = ["BHB_API_KEY", "BHB_API_SECRET", "BHB_API_CLIENT"];

export interface IStorage {
  getCustomers(): Promise<PortalCustomer[]>;
  getCustomer(id: string): Promise<PortalCustomer | undefined>;
  getCustomerByDebtorNumber(debtorNumber: number): Promise<PortalCustomer | undefined>;
  createCustomer(customer: InsertPortalCustomer & { lastBhbSync?: Date | null; bhbRawJson?: unknown }): Promise<PortalCustomer>;
  updateCustomer(id: string, customer: Partial<InsertPortalCustomer> & { lastBhbSync?: Date | null; bhbRawJson?: unknown }): Promise<PortalCustomer | undefined>;
  deleteCustomer(id: string): Promise<boolean>;
  
  getUserCustomers(userId: string): Promise<PortalUserCustomer[]>;
  assignUserToCustomer(data: InsertPortalUserCustomer): Promise<PortalUserCustomer>;
  removeUserFromCustomer(userId: string, customerId: string): Promise<boolean>;
  
  getReceipts(filters?: { debtorNumber?: number; status?: string }): Promise<BhbReceiptsCache[]>;
  getReceipt(id: string): Promise<BhbReceiptsCache | undefined>;
  getReceiptByIdByCustomer(idByCustomer: string): Promise<BhbReceiptsCache | undefined>;
  upsertReceipt(receipt: InsertBhbReceiptsCache): Promise<BhbReceiptsCache>;
  updateReceiptDebtor(receiptId: string, debtorNumber: number): Promise<void>;
  updateReceiptsDebtorNumber(oldDebtorNumber: number, newDebtorNumber: number): Promise<number>;
  updateCustomerDebtorNumberAtomic(
    customerId: string,
    oldDebtorNumber: number,
    newDebtorNumber: number,
    customerUpdate: Partial<InsertPortalCustomer> & { lastBhbSync?: Date | null; bhbRawJson?: unknown }
  ): Promise<{ receiptsUpdated: number }>;
  
  getDunningRules(customerId?: string): Promise<DunningRules[]>;
  getDunningRulesForCustomer(customerId: string): Promise<DunningRules | undefined>;
  upsertDunningRules(rules: InsertDunningRules): Promise<DunningRules>;
  
  getDunningEvents(receiptId: string): Promise<DunningEvent[]>;
  createDunningEvent(event: InsertDunningEvent): Promise<DunningEvent>;
  updateDunningEvent(id: string, data: Partial<InsertDunningEvent>): Promise<DunningEvent | undefined>;
  
  getDashboardStats(): Promise<{
    totalOpenAmount: number;
    overdueAmount: number;
    overdueCount: number;
    totalInvoices: number;
    dunningEmailsSent: number;
    customersCount: number;
  }>;
  getRecentInvoices(limit?: number): Promise<BhbReceiptsCache[]>;
  getReceiptsForUser(userId: string): Promise<BhbReceiptsCache[]>;
  getCustomersForUser(userId: string): Promise<PortalCustomer[]>;
  getDashboardStatsForUser(userId: string): Promise<{
    totalOpenAmount: number;
    overdueAmount: number;
    overdueCount: number;
    totalInvoices: number;
  }>;
  
  getUserByUsername(username: string): Promise<User | undefined>;
  getUserById(id: string): Promise<User | undefined>;
  createUser(username: string, password: string, displayName?: string, role?: string): Promise<User>;
  validateUserPassword(username: string, password: string): Promise<User | null>;
  getAllUsers(): Promise<User[]>;
  
  getSetting(key: string): Promise<string | null>;
  setSetting(key: string, value: string, userId?: string): Promise<PortalSetting>;
  getAllSettings(): Promise<PortalSetting[]>;
  
  deleteAutoGeneratedCustomers(): Promise<{ deleted: number; skipped: number; skippedNames: string[] }>;
  
  // Counterparty mappings
  getCounterpartyMappings(): Promise<CounterpartyMapping[]>;
  getCounterpartyMapping(counterpartyName: string): Promise<CounterpartyMapping | undefined>;
  createCounterpartyMapping(mapping: InsertCounterpartyMapping): Promise<CounterpartyMapping>;
  deleteCounterpartyMapping(id: string): Promise<boolean>;
  getUnmatchedCounterparties(): Promise<{ counterpartyName: string; count: number }[]>;
}

export class DatabaseStorage implements IStorage {
  async getCustomers(): Promise<PortalCustomer[]> {
    return db.select().from(portalCustomers).orderBy(portalCustomers.displayName);
  }

  async getCustomer(id: string): Promise<PortalCustomer | undefined> {
    const [customer] = await db.select().from(portalCustomers).where(eq(portalCustomers.id, id));
    return customer;
  }

  async getCustomerByDebtorNumber(debtorNumber: number): Promise<PortalCustomer | undefined> {
    const [customer] = await db
      .select()
      .from(portalCustomers)
      .where(eq(portalCustomers.debtorPostingaccountNumber, debtorNumber));
    return customer;
  }

  async createCustomer(customer: InsertPortalCustomer & { lastBhbSync?: Date | null; bhbRawJson?: unknown }): Promise<PortalCustomer> {
    const [created] = await db.insert(portalCustomers).values(customer).returning();
    return created;
  }

  async updateCustomer(id: string, customer: Partial<InsertPortalCustomer> & { lastBhbSync?: Date | null; bhbRawJson?: unknown }): Promise<PortalCustomer | undefined> {
    const [updated] = await db
      .update(portalCustomers)
      .set({ ...customer, updatedAt: new Date() })
      .where(eq(portalCustomers.id, id))
      .returning();
    return updated;
  }

  async deleteCustomer(id: string): Promise<boolean> {
    const existing = await this.getCustomer(id);
    if (!existing) {
      return false;
    }
    await db.delete(portalCustomers).where(eq(portalCustomers.id, id));
    return true;
  }

  async getUserCustomers(userId: string): Promise<PortalUserCustomer[]> {
    return db
      .select()
      .from(portalUserCustomers)
      .where(eq(portalUserCustomers.userId, userId));
  }

  async assignUserToCustomer(data: InsertPortalUserCustomer): Promise<PortalUserCustomer> {
    const [created] = await db.insert(portalUserCustomers).values(data).returning();
    return created;
  }

  async removeUserFromCustomer(userId: string, customerId: string): Promise<boolean> {
    await db
      .delete(portalUserCustomers)
      .where(
        and(
          eq(portalUserCustomers.userId, userId),
          eq(portalUserCustomers.customerId, customerId)
        )
      );
    return true;
  }

  async getReceipts(filters?: { debtorNumber?: number; status?: string }): Promise<BhbReceiptsCache[]> {
    let query = db.select().from(bhbReceiptsCache);
    
    if (filters?.debtorNumber) {
      query = query.where(eq(bhbReceiptsCache.debtorPostingaccountNumber, filters.debtorNumber)) as any;
    }
    if (filters?.status && filters.status !== "all") {
      query = query.where(eq(bhbReceiptsCache.paymentStatus, filters.status)) as any;
    }
    
    return query.orderBy(desc(bhbReceiptsCache.dueDate));
  }

  async getReceipt(id: string): Promise<BhbReceiptsCache | undefined> {
    const [receipt] = await db.select().from(bhbReceiptsCache).where(eq(bhbReceiptsCache.id, id));
    return receipt;
  }

  async getReceiptByIdByCustomer(idByCustomer: string): Promise<BhbReceiptsCache | undefined> {
    const [receipt] = await db
      .select()
      .from(bhbReceiptsCache)
      .where(eq(bhbReceiptsCache.idByCustomer, idByCustomer));
    return receipt;
  }

  async upsertReceipt(receipt: InsertBhbReceiptsCache): Promise<BhbReceiptsCache> {
    const [upserted] = await db
      .insert(bhbReceiptsCache)
      .values({ ...receipt, lastSyncedAt: new Date() })
      .onConflictDoUpdate({
        target: bhbReceiptsCache.idByCustomer,
        set: {
          ...receipt,
          lastSyncedAt: new Date(),
        },
      })
      .returning();
    return upserted;
  }

  async updateReceiptDebtor(receiptId: string, debtorNumber: number): Promise<void> {
    await db
      .update(bhbReceiptsCache)
      .set({ debtorPostingaccountNumber: debtorNumber })
      .where(eq(bhbReceiptsCache.id, receiptId));
  }

  async updateReceiptsDebtorNumber(oldDebtorNumber: number, newDebtorNumber: number): Promise<number> {
    const updated = await db
      .update(bhbReceiptsCache)
      .set({ debtorPostingaccountNumber: newDebtorNumber })
      .where(eq(bhbReceiptsCache.debtorPostingaccountNumber, oldDebtorNumber))
      .returning();
    return updated.length;
  }

  async updateCustomerDebtorNumberAtomic(
    customerId: string,
    oldDebtorNumber: number,
    newDebtorNumber: number,
    customerUpdate: Partial<InsertPortalCustomer> & { lastBhbSync?: Date | null; bhbRawJson?: unknown }
  ): Promise<{ receiptsUpdated: number }> {
    return await db.transaction(async (tx) => {
      const receiptsUpdated = await tx
        .update(bhbReceiptsCache)
        .set({ debtorPostingaccountNumber: newDebtorNumber })
        .where(eq(bhbReceiptsCache.debtorPostingaccountNumber, oldDebtorNumber))
        .returning();
      
      await tx
        .update(portalCustomers)
        .set({ ...customerUpdate, updatedAt: new Date() })
        .where(eq(portalCustomers.id, customerId));
      
      return { receiptsUpdated: receiptsUpdated.length };
    });
  }

  async getDunningRules(customerId?: string): Promise<DunningRules[]> {
    if (customerId) {
      return db.select().from(dunningRules).where(eq(dunningRules.customerId, customerId));
    }
    return db.select().from(dunningRules);
  }

  async getDunningRulesForCustomer(customerId: string): Promise<DunningRules | undefined> {
    const [rules] = await db.select().from(dunningRules).where(eq(dunningRules.customerId, customerId));
    return rules;
  }

  async upsertDunningRules(rules: InsertDunningRules): Promise<DunningRules> {
    const existing = await this.getDunningRulesForCustomer(rules.customerId);
    
    if (existing) {
      const [updated] = await db
        .update(dunningRules)
        .set({ ...rules, updatedAt: new Date() })
        .where(eq(dunningRules.id, existing.id))
        .returning();
      return updated;
    }
    
    const [created] = await db.insert(dunningRules).values(rules).returning();
    return created;
  }

  async getDunningEvents(receiptId: string): Promise<DunningEvent[]> {
    return db
      .select()
      .from(dunningEvents)
      .where(eq(dunningEvents.receiptId, receiptId))
      .orderBy(desc(dunningEvents.createdAt));
  }

  async createDunningEvent(event: InsertDunningEvent): Promise<DunningEvent> {
    const [created] = await db.insert(dunningEvents).values(event).returning();
    return created;
  }

  async updateDunningEvent(id: string, data: Partial<InsertDunningEvent>): Promise<DunningEvent | undefined> {
    const [updated] = await db
      .update(dunningEvents)
      .set(data)
      .where(eq(dunningEvents.id, id))
      .returning();
    return updated;
  }

  async getDashboardStats() {
    const today = new Date();
    const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    
    const receipts = await db.select().from(bhbReceiptsCache).where(eq(bhbReceiptsCache.paymentStatus, "unpaid"));
    const customers = await db.select().from(portalCustomers).where(eq(portalCustomers.isActive, true));
    const monthlyEvents = await db
      .select()
      .from(dunningEvents)
      .where(
        and(
          eq(dunningEvents.status, "sent"),
          sql`${dunningEvents.sentAt} >= ${startOfMonth}`
        )
      );

    let totalOpenAmount = 0;
    let overdueAmount = 0;
    let overdueCount = 0;

    for (const receipt of receipts) {
      const amount = parseFloat(receipt.amountOpen?.toString() || receipt.amountTotal?.toString() || "0");
      totalOpenAmount += amount;
      
      if (receipt.dueDate && new Date(receipt.dueDate) < today) {
        overdueAmount += amount;
        overdueCount++;
      }
    }

    // Calculate breakdown by overdue status
    let notDueCount = 0;
    let notDueAmount = 0;
    let overdue1to30Count = 0;
    let overdue1to30Amount = 0;
    let overdue30plusCount = 0;
    let overdue30plusAmount = 0;

    for (const receipt of receipts) {
      const amount = parseFloat(receipt.amountOpen?.toString() || receipt.amountTotal?.toString() || "0");
      if (amount <= 0) continue;
      
      if (!receipt.dueDate) {
        notDueCount++;
        notDueAmount += amount;
      } else {
        const dueDate = new Date(receipt.dueDate);
        const daysOverdue = Math.floor((today.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24));
        
        if (daysOverdue <= 0) {
          notDueCount++;
          notDueAmount += amount;
        } else if (daysOverdue <= 30) {
          overdue1to30Count++;
          overdue1to30Amount += amount;
        } else {
          overdue30plusCount++;
          overdue30plusAmount += amount;
        }
      }
    }

    return {
      totalOpenAmount,
      overdueAmount,
      overdueCount,
      totalInvoices: receipts.length,
      dunningEmailsSent: monthlyEvents.length,
      customersCount: customers.length,
      notDueCount,
      notDueAmount,
      overdue1to30Count,
      overdue1to30Amount,
      overdue30plusCount,
      overdue30plusAmount,
    };
  }

  async getRecentInvoices(limit = 10): Promise<BhbReceiptsCache[]> {
    return db
      .select()
      .from(bhbReceiptsCache)
      .where(eq(bhbReceiptsCache.paymentStatus, "unpaid"))
      .orderBy(desc(bhbReceiptsCache.dueDate))
      .limit(limit);
  }

  async getCustomersForUser(userId: string): Promise<PortalCustomer[]> {
    const userCustomerLinks = await db
      .select()
      .from(portalUserCustomers)
      .where(eq(portalUserCustomers.userId, userId));
    
    if (userCustomerLinks.length === 0) return [];
    
    const customerIds = userCustomerLinks.map(uc => uc.customerId);
    const customers: PortalCustomer[] = [];
    
    for (const customerId of customerIds) {
      const [customer] = await db
        .select()
        .from(portalCustomers)
        .where(eq(portalCustomers.id, customerId));
      if (customer) customers.push(customer);
    }
    
    return customers;
  }

  async getReceiptsForUser(userId: string): Promise<BhbReceiptsCache[]> {
    const customers = await this.getCustomersForUser(userId);
    if (customers.length === 0) return [];
    
    const debtorNumbers = customers.map(c => c.debtorPostingaccountNumber);
    const receipts: BhbReceiptsCache[] = [];
    
    for (const debtorNumber of debtorNumbers) {
      const customerReceipts = await db
        .select()
        .from(bhbReceiptsCache)
        .where(eq(bhbReceiptsCache.debtorPostingaccountNumber, debtorNumber));
      receipts.push(...customerReceipts);
    }
    
    return receipts.sort((a, b) => {
      const dateA = a.dueDate ? new Date(a.dueDate).getTime() : 0;
      const dateB = b.dueDate ? new Date(b.dueDate).getTime() : 0;
      return dateB - dateA;
    });
  }

  async getDashboardStatsForUser(userId: string): Promise<{
    totalOpenAmount: number;
    overdueAmount: number;
    overdueCount: number;
    totalInvoices: number;
  }> {
    const today = new Date();
    const receipts = await this.getReceiptsForUser(userId);
    const unpaidReceipts = receipts.filter(r => r.paymentStatus === "unpaid");

    let totalOpenAmount = 0;
    let overdueAmount = 0;
    let overdueCount = 0;

    for (const receipt of unpaidReceipts) {
      const amount = parseFloat(receipt.amountOpen?.toString() || receipt.amountTotal?.toString() || "0");
      totalOpenAmount += amount;
      
      if (receipt.dueDate && new Date(receipt.dueDate) < today) {
        overdueAmount += amount;
        overdueCount++;
      }
    }

    return {
      totalOpenAmount,
      overdueAmount,
      overdueCount,
      totalInvoices: unpaidReceipts.length,
    };
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user;
  }

  async getUserById(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async createUser(username: string, password: string, displayName?: string, role: string = "user"): Promise<User> {
    const passwordHash = await bcrypt.hash(password, 10);
    const [user] = await db.insert(users).values({
      username,
      passwordHash,
      displayName: displayName || username,
      role,
    }).returning();
    return user;
  }

  async validateUserPassword(username: string, password: string): Promise<User | null> {
    const user = await this.getUserByUsername(username);
    if (!user || !user.passwordHash) {
      return null;
    }
    const isValid = await bcrypt.compare(password, user.passwordHash);
    return isValid ? user : null;
  }

  async getAllUsers(): Promise<User[]> {
    return db.select().from(users).orderBy(users.username);
  }

  async getSetting(key: string): Promise<string | null> {
    const [setting] = await db.select().from(portalSettings).where(eq(portalSettings.settingKey, key));
    if (!setting?.settingValue) return null;
    
    if (SENSITIVE_SETTINGS.includes(key) && isEncrypted(setting.settingValue)) {
      try {
        return decrypt(setting.settingValue);
      } catch (error) {
        console.error(`Failed to decrypt setting ${key}:`, error);
        return null;
      }
    }
    
    return setting.settingValue;
  }

  async setSetting(key: string, value: string, userId?: string): Promise<PortalSetting> {
    const storedValue = SENSITIVE_SETTINGS.includes(key) ? encrypt(value) : value;
    const isEncryptedFlag = SENSITIVE_SETTINGS.includes(key) ? "true" : "false";
    
    const [existing] = await db.select().from(portalSettings).where(eq(portalSettings.settingKey, key));
    
    if (existing) {
      const [updated] = await db
        .update(portalSettings)
        .set({ settingValue: storedValue, isEncrypted: isEncryptedFlag, updatedBy: userId, updatedAt: new Date() })
        .where(eq(portalSettings.settingKey, key))
        .returning();
      return updated;
    }
    
    const [created] = await db.insert(portalSettings).values({
      settingKey: key,
      settingValue: storedValue,
      isEncrypted: isEncryptedFlag,
      updatedBy: userId,
    }).returning();
    return created;
  }

  async getAllSettings(): Promise<PortalSetting[]> {
    return db.select().from(portalSettings);
  }

  async deleteAutoGeneratedCustomers(): Promise<{ deleted: number; skipped: number; skippedNames: string[] }> {
    return await db.transaction(async (tx) => {
      const autoGeneratedCustomers = await tx
        .select()
        .from(portalCustomers)
        .where(
          and(
            sql`${portalCustomers.debtorPostingaccountNumber} >= 80000`,
            sql`${portalCustomers.debtorPostingaccountNumber} < 90000`
          )
        );
      
      let deleted = 0;
      let skipped = 0;
      const skippedNames: string[] = [];
      
      for (const customer of autoGeneratedCustomers) {
        const receiptsWithThisDebtor = await tx
          .select()
          .from(bhbReceiptsCache)
          .where(eq(bhbReceiptsCache.debtorPostingaccountNumber, customer.debtorPostingaccountNumber));
        
        if (receiptsWithThisDebtor.length > 0) {
          skipped++;
          skippedNames.push(`${customer.displayName} (${receiptsWithThisDebtor.length} Rechnungen)`);
          continue;
        }
        
        await tx.delete(dunningRules).where(eq(dunningRules.customerId, customer.id));
        await tx.delete(portalUserCustomers).where(eq(portalUserCustomers.customerId, customer.id));
        await tx.delete(portalCustomers).where(eq(portalCustomers.id, customer.id));
        deleted++;
      }
      
      return { deleted, skipped, skippedNames: skippedNames.slice(0, 10) };
    });
  }

  // Counterparty mappings
  async getCounterpartyMappings(): Promise<CounterpartyMapping[]> {
    return db.select().from(counterpartyMappings).orderBy(counterpartyMappings.counterpartyName);
  }

  async getCounterpartyMapping(counterpartyName: string): Promise<CounterpartyMapping | undefined> {
    const [mapping] = await db
      .select()
      .from(counterpartyMappings)
      .where(eq(counterpartyMappings.counterpartyName, counterpartyName));
    return mapping;
  }

  async createCounterpartyMapping(mapping: InsertCounterpartyMapping): Promise<CounterpartyMapping> {
    const [created] = await db
      .insert(counterpartyMappings)
      .values(mapping)
      .onConflictDoUpdate({
        target: counterpartyMappings.counterpartyName,
        set: { debtorPostingaccountNumber: mapping.debtorPostingaccountNumber },
      })
      .returning();
    return created;
  }

  async deleteCounterpartyMapping(id: string): Promise<boolean> {
    const result = await db.delete(counterpartyMappings).where(eq(counterpartyMappings.id, id)).returning();
    return result.length > 0;
  }

  async getUnmatchedCounterparties(): Promise<{ counterpartyName: string; count: number }[]> {
    const receipts = await db
      .select()
      .from(bhbReceiptsCache)
      .where(eq(bhbReceiptsCache.debtorPostingaccountNumber, 0));
    
    const countMap = new Map<string, number>();
    for (const receipt of receipts) {
      const name = (receipt.rawJson as any)?.counterparty;
      if (name) {
        countMap.set(name, (countMap.get(name) || 0) + 1);
      }
    }
    
    return Array.from(countMap.entries())
      .map(([counterpartyName, count]) => ({ counterpartyName, count }))
      .sort((a, b) => b.count - a.count);
  }
}

export const storage = new DatabaseStorage();
