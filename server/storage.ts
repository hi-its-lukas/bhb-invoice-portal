import {
  portalCustomers,
  portalUserCustomers,
  bhbReceiptsCache,
  dunningRules,
  dunningEvents,
  dunningEmailTemplates,
  users,
  portalSettings,
  counterpartyMappings,
  counterpartyExceptions,
  brandingConfig,
  syncLogs,
  type PortalCustomer,
  type InsertPortalCustomer,
  type PortalUserCustomer,
  type InsertPortalUserCustomer,
  type BhbReceiptsCache,
  type InsertBhbReceiptsCache,
  type DunningRules,
  type InsertDunningRules,
  type DunningEvent,
  type InsertDunningEvent,
  type DunningEmailTemplate,
  type InsertDunningEmailTemplate,
  type User,
  type InsertUser,
  type PortalSetting,
  type CounterpartyMapping,
  type InsertCounterpartyMapping,
  type BrandingConfig,
  type BrandingConfigRow,
  type SyncLog,
  type InsertSyncLog,
} from "@shared/schema";
import { db } from "./db";
import { eq, and, desc, sql, lte, isNull, or } from "drizzle-orm";
import bcrypt from "bcryptjs";
import { encrypt, decrypt, isEncrypted } from "./crypto";

const SENSITIVE_SETTINGS = ["BHB_API_KEY", "BHB_API_SECRET", "BHB_API_CLIENT", "SMTP_PASSWORD", "GRAPH_CLIENT_SECRET"];

export interface IStorage {
  getCustomers(): Promise<PortalCustomer[]>;
  getCustomer(id: string): Promise<PortalCustomer | undefined>;
  getCustomerByDebtorNumber(debtorNumber: number): Promise<PortalCustomer | undefined>;
  getCustomerByName(name: string): Promise<PortalCustomer | undefined>;
  createCustomer(customer: InsertPortalCustomer & { lastBhbSync?: Date | null; bhbRawJson?: unknown; bhbDataHash?: string }): Promise<PortalCustomer>;
  updateCustomer(id: string, customer: Partial<InsertPortalCustomer> & { lastBhbSync?: Date | null; bhbRawJson?: unknown; bhbDataHash?: string }): Promise<PortalCustomer | undefined>;
  deleteCustomer(id: string): Promise<boolean>;
  
  getUserCustomers(userId: string): Promise<PortalUserCustomer[]>;
  assignUserToCustomer(data: InsertPortalUserCustomer): Promise<PortalUserCustomer>;
  removeUserFromCustomer(userId: string, customerId: string): Promise<boolean>;
  
  getReceipts(filters?: { debtorNumber?: number; status?: string }): Promise<BhbReceiptsCache[]>;
  getReceipt(id: string): Promise<BhbReceiptsCache | undefined>;
  getReceiptByIdByCustomer(idByCustomer: string): Promise<BhbReceiptsCache | undefined>;
  upsertReceipt(receipt: InsertBhbReceiptsCache): Promise<BhbReceiptsCache>;
  updateReceiptDebtor(receiptId: string, debtorNumber: number): Promise<void>;
  updateReceiptStatus(receiptId: string, data: { paymentStatus?: string; dunningLevel?: string }): Promise<BhbReceiptsCache | undefined>;
  updateReceiptsDebtorNumber(oldDebtorNumber: number, newDebtorNumber: number): Promise<number>;
  updateCustomerDebtorNumberAtomic(
    customerId: string,
    oldDebtorNumber: number,
    newDebtorNumber: number,
    customerUpdate: Partial<InsertPortalCustomer> & { lastBhbSync?: Date | null; bhbRawJson?: unknown; bhbDataHash?: string }
  ): Promise<{ receiptsUpdated: number }>;
  
  getDunningRules(customerId?: string): Promise<DunningRules[]>;
  getDunningRulesForCustomer(customerId: string): Promise<DunningRules | undefined>;
  upsertDunningRules(rules: InsertDunningRules): Promise<DunningRules>;
  
  getDunningEvents(receiptId: string): Promise<DunningEvent[]>;
  createDunningEvent(event: InsertDunningEvent): Promise<DunningEvent>;
  updateDunningEvent(id: string, data: Partial<InsertDunningEvent>): Promise<DunningEvent | undefined>;
  
  getDashboardStats(): Promise<{
    totalOpenAmount: number;
    overdueAmount: number;
    overdueCount: number;
    totalInvoices: number;
    dunningEmailsSent: number;
    customersCount: number;
  }>;
  getRecentInvoices(limit?: number): Promise<BhbReceiptsCache[]>;
  getReceiptsForUser(userId: string): Promise<BhbReceiptsCache[]>;
  getCustomersForUser(userId: string): Promise<PortalCustomer[]>;
  getDashboardStatsForUser(userId: string): Promise<{
    totalOpenAmount: number;
    overdueAmount: number;
    overdueCount: number;
    totalInvoices: number;
  }>;
  
  getUserByUsername(username: string): Promise<User | undefined>;
  getUserById(id: string): Promise<User | undefined>;
  createUser(username: string, password: string, displayName?: string, role?: string): Promise<User>;
  updateUser(id: string, data: { displayName?: string; role?: string; password?: string }): Promise<User | undefined>;
  deleteUser(id: string): Promise<boolean>;
  validateUserPassword(username: string, password: string): Promise<User | null>;
  getAllUsers(): Promise<User[]>;
  getInternalUsers(): Promise<User[]>;
  countAdmins(): Promise<number>;
  
  getSetting(key: string): Promise<string | null>;
  setSetting(key: string, value: string, userId?: string): Promise<PortalSetting>;
  getAllSettings(): Promise<PortalSetting[]>;
  
  deleteAutoGeneratedCustomers(): Promise<{ deleted: number; skipped: number; skippedNames: string[] }>;
  
  // Counterparty mappings
  getCounterpartyMappings(): Promise<CounterpartyMapping[]>;
  getCounterpartyMapping(counterpartyName: string): Promise<CounterpartyMapping | undefined>;
  createCounterpartyMapping(mapping: InsertCounterpartyMapping): Promise<CounterpartyMapping>;
  deleteCounterpartyMapping(id: string): Promise<boolean>;
  getUnmatchedCounterparties(): Promise<{ counterpartyName: string; count: number }[]>;
  
  getCounterpartyExceptions(): Promise<{ id: string; counterpartyName: string; status: string; note: string | null }[]>;
  createCounterpartyException(counterpartyName: string, status?: string, note?: string): Promise<{ id: string; counterpartyName: string; status: string }>;
  deleteCounterpartyException(id: string): Promise<boolean>;
  
  // Dunning email templates
  getDunningEmailTemplates(): Promise<DunningEmailTemplate[]>;
  getDunningEmailTemplate(id: string): Promise<DunningEmailTemplate | undefined>;
  getDunningEmailTemplatesByStage(stage: string): Promise<DunningEmailTemplate[]>;
  createDunningEmailTemplate(template: InsertDunningEmailTemplate): Promise<DunningEmailTemplate>;
  updateDunningEmailTemplate(id: string, template: Partial<InsertDunningEmailTemplate>): Promise<DunningEmailTemplate | undefined>;
  deleteDunningEmailTemplate(id: string): Promise<boolean>;
  
  // Dunning events for customer
  getDunningEventsForCustomer(customerId: string): Promise<DunningEvent[]>;
  createDunningEventForCustomer(event: Omit<InsertDunningEvent, "receiptId"> & { customerId: string }): Promise<DunningEvent>;
  
  // Customer open invoice statistics
  getCustomerOpenInvoiceStats(): Promise<Map<number, { count: number; totalOpen: number; overdueCount: number }>>;
  
  // Branding configuration
  getBrandingConfig(): Promise<BrandingConfig>;
  setBrandingConfig(config: Partial<BrandingConfig>): Promise<BrandingConfig>;
  getBrandingConfigValue(key: string): Promise<string | null>;
  setBrandingConfigValue(key: string, value: string, category?: string): Promise<BrandingConfigRow>;
  
  // Sync logs
  getSyncLogs(limit?: number): Promise<SyncLog[]>;
  getSyncLog(id: string): Promise<SyncLog | undefined>;
  createSyncLog(log: InsertSyncLog): Promise<SyncLog>;
  updateSyncLog(id: string, data: Partial<InsertSyncLog>): Promise<SyncLog | undefined>;
  getLastSyncLog(entityType?: string): Promise<SyncLog | undefined>;
}

export class DatabaseStorage implements IStorage {
  async getCustomers(): Promise<PortalCustomer[]> {
    return db.select().from(portalCustomers).orderBy(portalCustomers.displayName);
  }

  async getCustomer(id: string): Promise<PortalCustomer | undefined> {
    const [customer] = await db.select().from(portalCustomers).where(eq(portalCustomers.id, id));
    return customer;
  }

  async getCustomerByDebtorNumber(debtorNumber: number): Promise<PortalCustomer | undefined> {
    const [customer] = await db
      .select()
      .from(portalCustomers)
      .where(eq(portalCustomers.debtorPostingaccountNumber, debtorNumber));
    return customer;
  }

  async getCustomerByName(name: string): Promise<PortalCustomer | undefined> {
    // Try exact match first, then fuzzy match
    const [exactMatch] = await db
      .select()
      .from(portalCustomers)
      .where(eq(portalCustomers.displayName, name));
    if (exactMatch) return exactMatch;

    // Try partial match (counterparty name might be truncated in BHB)
    const allCustomers = await db.select().from(portalCustomers);
    return allCustomers.find(c => 
      c.displayName.toLowerCase().includes(name.toLowerCase()) ||
      name.toLowerCase().includes(c.displayName.toLowerCase())
    );
  }

  async createCustomer(customer: InsertPortalCustomer & { lastBhbSync?: Date | null; bhbRawJson?: unknown; bhbDataHash?: string }): Promise<PortalCustomer> {
    const [created] = await db.insert(portalCustomers).values(customer).returning();
    return created;
  }

  async updateCustomer(id: string, customer: Partial<InsertPortalCustomer> & { lastBhbSync?: Date | null; bhbRawJson?: unknown; bhbDataHash?: string }): Promise<PortalCustomer | undefined> {
    console.log(`[storage] updateCustomer ${id}, bhbDataHash in input: ${customer.bhbDataHash}`);
    const [updated] = await db
      .update(portalCustomers)
      .set({ ...customer, updatedAt: new Date() })
      .where(eq(portalCustomers.id, id))
      .returning();
    console.log(`[storage] updateCustomer result, bhbDataHash: ${updated?.bhbDataHash}`);
    return updated;
  }

  async deleteCustomer(id: string): Promise<boolean> {
    const existing = await this.getCustomer(id);
    if (!existing) {
      return false;
    }
    await db.delete(portalCustomers).where(eq(portalCustomers.id, id));
    return true;
  }

  async getUserCustomers(userId: string): Promise<PortalUserCustomer[]> {
    return db
      .select()
      .from(portalUserCustomers)
      .where(eq(portalUserCustomers.userId, userId));
  }

  async assignUserToCustomer(data: InsertPortalUserCustomer): Promise<PortalUserCustomer> {
    const [created] = await db.insert(portalUserCustomers).values(data).returning();
    return created;
  }

  async removeUserFromCustomer(userId: string, customerId: string): Promise<boolean> {
    await db
      .delete(portalUserCustomers)
      .where(
        and(
          eq(portalUserCustomers.userId, userId),
          eq(portalUserCustomers.customerId, customerId)
        )
      );
    return true;
  }

  async getReceipts(filters?: { debtorNumber?: number; status?: string }): Promise<BhbReceiptsCache[]> {
    let query = db.select().from(bhbReceiptsCache);
    
    if (filters?.debtorNumber) {
      query = query.where(eq(bhbReceiptsCache.debtorPostingaccountNumber, filters.debtorNumber)) as any;
    }
    if (filters?.status && filters.status !== "all") {
      query = query.where(eq(bhbReceiptsCache.paymentStatus, filters.status)) as any;
    }
    
    return query.orderBy(desc(bhbReceiptsCache.dueDate));
  }

  async getReceipt(id: string): Promise<BhbReceiptsCache | undefined> {
    const [receipt] = await db.select().from(bhbReceiptsCache).where(eq(bhbReceiptsCache.id, id));
    return receipt;
  }

  async getReceiptByIdByCustomer(idByCustomer: string): Promise<BhbReceiptsCache | undefined> {
    const [receipt] = await db
      .select()
      .from(bhbReceiptsCache)
      .where(eq(bhbReceiptsCache.idByCustomer, idByCustomer));
    return receipt;
  }

  async upsertReceipt(receipt: InsertBhbReceiptsCache): Promise<BhbReceiptsCache> {
    const [upserted] = await db
      .insert(bhbReceiptsCache)
      .values({ ...receipt, lastSyncedAt: new Date() })
      .onConflictDoUpdate({
        target: bhbReceiptsCache.idByCustomer,
        set: {
          debtorPostingaccountNumber: receipt.debtorPostingaccountNumber,
          invoiceNumber: receipt.invoiceNumber,
          receiptDate: receipt.receiptDate,
          dueDate: receipt.dueDate,
          amountTotal: receipt.amountTotal,
          amountOpen: receipt.amountOpen,
          paymentStatus: receipt.paymentStatus,
          rawJson: receipt.rawJson,
          lastSyncedAt: new Date(),
        },
      })
      .returning();
    return upserted;
  }

  async updateReceiptDebtor(receiptId: string, debtorNumber: number): Promise<void> {
    await db
      .update(bhbReceiptsCache)
      .set({ debtorPostingaccountNumber: debtorNumber })
      .where(eq(bhbReceiptsCache.id, receiptId));
  }

  async updateReceiptStatus(receiptId: string, data: { paymentStatus?: string; dunningLevel?: string }): Promise<BhbReceiptsCache | undefined> {
    const [updated] = await db
      .update(bhbReceiptsCache)
      .set(data)
      .where(eq(bhbReceiptsCache.id, receiptId))
      .returning();
    return updated;
  }

  async updateReceiptsDebtorNumber(oldDebtorNumber: number, newDebtorNumber: number): Promise<number> {
    const updated = await db
      .update(bhbReceiptsCache)
      .set({ debtorPostingaccountNumber: newDebtorNumber })
      .where(eq(bhbReceiptsCache.debtorPostingaccountNumber, oldDebtorNumber))
      .returning();
    return updated.length;
  }

  async updateCustomerDebtorNumberAtomic(
    customerId: string,
    oldDebtorNumber: number,
    newDebtorNumber: number,
    customerUpdate: Partial<InsertPortalCustomer> & { lastBhbSync?: Date | null; bhbRawJson?: unknown; bhbDataHash?: string }
  ): Promise<{ receiptsUpdated: number }> {
    return await db.transaction(async (tx) => {
      const receiptsUpdated = await tx
        .update(bhbReceiptsCache)
        .set({ debtorPostingaccountNumber: newDebtorNumber })
        .where(eq(bhbReceiptsCache.debtorPostingaccountNumber, oldDebtorNumber))
        .returning();
      
      await tx
        .update(portalCustomers)
        .set({ ...customerUpdate, updatedAt: new Date() })
        .where(eq(portalCustomers.id, customerId));
      
      return { receiptsUpdated: receiptsUpdated.length };
    });
  }

  async getDunningRules(customerId?: string): Promise<DunningRules[]> {
    if (customerId) {
      return db.select().from(dunningRules).where(eq(dunningRules.customerId, customerId));
    }
    return db.select().from(dunningRules);
  }

  async getDunningRulesForCustomer(customerId: string): Promise<DunningRules | undefined> {
    const [rules] = await db.select().from(dunningRules).where(eq(dunningRules.customerId, customerId));
    return rules;
  }

  async upsertDunningRules(rules: InsertDunningRules): Promise<DunningRules> {
    const existing = await this.getDunningRulesForCustomer(rules.customerId);
    
    if (existing) {
      const [updated] = await db
        .update(dunningRules)
        .set({ ...rules, updatedAt: new Date() })
        .where(eq(dunningRules.id, existing.id))
        .returning();
      return updated;
    }
    
    const [created] = await db.insert(dunningRules).values(rules).returning();
    return created;
  }

  async getDunningEvents(receiptId: string): Promise<DunningEvent[]> {
    return db
      .select()
      .from(dunningEvents)
      .where(eq(dunningEvents.receiptId, receiptId))
      .orderBy(desc(dunningEvents.createdAt));
  }

  async createDunningEvent(event: InsertDunningEvent): Promise<DunningEvent> {
    const [created] = await db.insert(dunningEvents).values(event).returning();
    return created;
  }

  async updateDunningEvent(id: string, data: Partial<InsertDunningEvent>): Promise<DunningEvent | undefined> {
    const [updated] = await db
      .update(dunningEvents)
      .set(data)
      .where(eq(dunningEvents.id, id))
      .returning();
    return updated;
  }

  async getDashboardStats() {
    const today = new Date();
    const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    
    const receipts = await db.select().from(bhbReceiptsCache).where(eq(bhbReceiptsCache.paymentStatus, "unpaid"));
    const allCustomers = await db.select().from(portalCustomers);
    const activeCustomers = allCustomers.filter(c => c.isActive);
    const monthlyEvents = await db
      .select()
      .from(dunningEvents)
      .where(
        and(
          eq(dunningEvents.status, "sent"),
          sql`${dunningEvents.sentAt} >= ${startOfMonth}`
        )
      );

    // Build lookup map for customers by debtorPostingaccountNumber
    const customerByDebtorNum = new Map<number, typeof allCustomers[0]>();
    for (const customer of allCustomers) {
      if (customer.debtorPostingaccountNumber) {
        customerByDebtorNum.set(customer.debtorPostingaccountNumber, customer);
      }
    }

    // Helper to calculate effective due date
    const getEffectiveDueDate = (receipt: typeof receipts[0]): Date | null => {
      // If explicit dueDate exists, use it
      if (receipt.dueDate) {
        return new Date(receipt.dueDate);
      }
      // Otherwise, calculate from receiptDate + customer paymentTermDays
      if (receipt.receiptDate) {
        const customer = receipt.debtorPostingaccountNumber 
          ? customerByDebtorNum.get(receipt.debtorPostingaccountNumber)
          : undefined;
        const paymentTermDays = customer?.paymentTermDays ?? 14; // Default to 14 days
        const receiptDate = new Date(receipt.receiptDate);
        receiptDate.setDate(receiptDate.getDate() + paymentTermDays);
        return receiptDate;
      }
      return null;
    };

    let totalOpenAmount = 0;
    let overdueAmount = 0;
    let overdueCount = 0;

    for (const receipt of receipts) {
      const amount = parseFloat(receipt.amountOpen?.toString() || receipt.amountTotal?.toString() || "0");
      totalOpenAmount += amount;
      
      const effectiveDueDate = getEffectiveDueDate(receipt);
      if (effectiveDueDate && effectiveDueDate < today) {
        overdueAmount += amount;
        overdueCount++;
      }
    }

    // Calculate breakdown by overdue status
    let notDueCount = 0;
    let notDueAmount = 0;
    let overdue1to30Count = 0;
    let overdue1to30Amount = 0;
    let overdue30plusCount = 0;
    let overdue30plusAmount = 0;

    for (const receipt of receipts) {
      const amount = parseFloat(receipt.amountOpen?.toString() || receipt.amountTotal?.toString() || "0");
      if (amount <= 0) continue;
      
      const effectiveDueDate = getEffectiveDueDate(receipt);
      if (!effectiveDueDate) {
        notDueCount++;
        notDueAmount += amount;
      } else {
        const daysOverdue = Math.floor((today.getTime() - effectiveDueDate.getTime()) / (1000 * 60 * 60 * 24));
        
        if (daysOverdue <= 0) {
          notDueCount++;
          notDueAmount += amount;
        } else if (daysOverdue <= 30) {
          overdue1to30Count++;
          overdue1to30Amount += amount;
        } else {
          overdue30plusCount++;
          overdue30plusAmount += amount;
        }
      }
    }

    return {
      totalOpenAmount,
      overdueAmount,
      overdueCount,
      totalInvoices: receipts.length,
      dunningEmailsSent: monthlyEvents.length,
      customersCount: activeCustomers.length,
      notDueCount,
      notDueAmount,
      overdue1to30Count,
      overdue1to30Amount,
      overdue30plusCount,
      overdue30plusAmount,
    };
  }

  async getRecentInvoices(limit = 10): Promise<BhbReceiptsCache[]> {
    return db
      .select()
      .from(bhbReceiptsCache)
      .where(eq(bhbReceiptsCache.paymentStatus, "unpaid"))
      .orderBy(desc(bhbReceiptsCache.dueDate))
      .limit(limit);
  }

  async getCustomersForUser(userId: string): Promise<PortalCustomer[]> {
    const userCustomerLinks = await db
      .select()
      .from(portalUserCustomers)
      .where(eq(portalUserCustomers.userId, userId));
    
    if (userCustomerLinks.length === 0) return [];
    
    const customerIds = userCustomerLinks.map(uc => uc.customerId);
    const customers: PortalCustomer[] = [];
    
    for (const customerId of customerIds) {
      const [customer] = await db
        .select()
        .from(portalCustomers)
        .where(eq(portalCustomers.id, customerId));
      if (customer) customers.push(customer);
    }
    
    return customers;
  }

  async getReceiptsForUser(userId: string): Promise<BhbReceiptsCache[]> {
    const customers = await this.getCustomersForUser(userId);
    if (customers.length === 0) return [];
    
    const debtorNumbers = customers.map(c => c.debtorPostingaccountNumber);
    const receipts: BhbReceiptsCache[] = [];
    
    for (const debtorNumber of debtorNumbers) {
      const customerReceipts = await db
        .select()
        .from(bhbReceiptsCache)
        .where(eq(bhbReceiptsCache.debtorPostingaccountNumber, debtorNumber));
      receipts.push(...customerReceipts);
    }
    
    return receipts.sort((a, b) => {
      const dateA = a.dueDate ? new Date(a.dueDate).getTime() : 0;
      const dateB = b.dueDate ? new Date(b.dueDate).getTime() : 0;
      return dateB - dateA;
    });
  }

  async getDashboardStatsForUser(userId: string): Promise<{
    totalOpenAmount: number;
    overdueAmount: number;
    overdueCount: number;
    totalInvoices: number;
  }> {
    const today = new Date();
    const receipts = await this.getReceiptsForUser(userId);
    const unpaidReceipts = receipts.filter(r => r.paymentStatus === "unpaid");

    let totalOpenAmount = 0;
    let overdueAmount = 0;
    let overdueCount = 0;

    for (const receipt of unpaidReceipts) {
      const amount = parseFloat(receipt.amountOpen?.toString() || receipt.amountTotal?.toString() || "0");
      totalOpenAmount += amount;
      
      if (receipt.dueDate && new Date(receipt.dueDate) < today) {
        overdueAmount += amount;
        overdueCount++;
      }
    }

    return {
      totalOpenAmount,
      overdueAmount,
      overdueCount,
      totalInvoices: unpaidReceipts.length,
    };
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.username, username));
    return user;
  }

  async getUserById(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async createUser(username: string, password: string, displayName?: string, role: string = "user"): Promise<User> {
    const passwordHash = await bcrypt.hash(password, 10);
    const [user] = await db.insert(users).values({
      username,
      passwordHash,
      displayName: displayName || username,
      role,
    }).returning();
    return user;
  }

  async validateUserPassword(username: string, password: string): Promise<User | null> {
    const user = await this.getUserByUsername(username);
    if (!user || !user.passwordHash) {
      return null;
    }
    const isValid = await bcrypt.compare(password, user.passwordHash);
    return isValid ? user : null;
  }

  async getAllUsers(): Promise<User[]> {
    return db.select().from(users).orderBy(users.username);
  }

  async getInternalUsers(): Promise<User[]> {
    return db.select().from(users)
      .where(sql`${users.role} != 'customer'`)
      .orderBy(users.username);
  }

  async countAdmins(): Promise<number> {
    const result = await db.select({ count: sql<number>`count(*)` })
      .from(users)
      .where(eq(users.role, "admin"));
    return Number(result[0]?.count || 0);
  }

  async updateUser(id: string, data: { displayName?: string; role?: string; password?: string }): Promise<User | undefined> {
    const updateData: Record<string, unknown> = {};
    
    if (data.displayName !== undefined) {
      updateData.displayName = data.displayName;
    }
    if (data.role !== undefined) {
      updateData.role = data.role;
    }
    if (data.password !== undefined && data.password.length > 0) {
      updateData.passwordHash = await bcrypt.hash(data.password, 10);
    }
    
    if (Object.keys(updateData).length === 0) {
      return this.getUserById(id);
    }
    
    const [updated] = await db.update(users)
      .set(updateData)
      .where(eq(users.id, id))
      .returning();
    return updated;
  }

  async deleteUser(id: string): Promise<boolean> {
    const result = await db.delete(users).where(eq(users.id, id));
    return (result.rowCount ?? 0) > 0;
  }

  async getSetting(key: string): Promise<string | null> {
    const [setting] = await db.select().from(portalSettings).where(eq(portalSettings.settingKey, key));
    if (!setting?.settingValue) return null;
    
    if (SENSITIVE_SETTINGS.includes(key) && isEncrypted(setting.settingValue)) {
      try {
        return decrypt(setting.settingValue);
      } catch (error) {
        console.error(`Failed to decrypt setting ${key}:`, error);
        return null;
      }
    }
    
    return setting.settingValue;
  }

  async setSetting(key: string, value: string, userId?: string): Promise<PortalSetting> {
    const storedValue = SENSITIVE_SETTINGS.includes(key) ? encrypt(value) : value;
    const isEncryptedFlag = SENSITIVE_SETTINGS.includes(key) ? "true" : "false";
    
    const [existing] = await db.select().from(portalSettings).where(eq(portalSettings.settingKey, key));
    
    if (existing) {
      const [updated] = await db
        .update(portalSettings)
        .set({ settingValue: storedValue, isEncrypted: isEncryptedFlag, updatedBy: userId, updatedAt: new Date() })
        .where(eq(portalSettings.settingKey, key))
        .returning();
      return updated;
    }
    
    const [created] = await db.insert(portalSettings).values({
      settingKey: key,
      settingValue: storedValue,
      isEncrypted: isEncryptedFlag,
      updatedBy: userId,
    }).returning();
    return created;
  }

  async getAllSettings(): Promise<PortalSetting[]> {
    return db.select().from(portalSettings);
  }

  async deleteAutoGeneratedCustomers(): Promise<{ deleted: number; skipped: number; skippedNames: string[] }> {
    return await db.transaction(async (tx) => {
      const autoGeneratedCustomers = await tx
        .select()
        .from(portalCustomers)
        .where(
          and(
            sql`${portalCustomers.debtorPostingaccountNumber} >= 80000`,
            sql`${portalCustomers.debtorPostingaccountNumber} < 90000`
          )
        );
      
      let deleted = 0;
      let skipped = 0;
      const skippedNames: string[] = [];
      
      for (const customer of autoGeneratedCustomers) {
        const receiptsWithThisDebtor = await tx
          .select()
          .from(bhbReceiptsCache)
          .where(eq(bhbReceiptsCache.debtorPostingaccountNumber, customer.debtorPostingaccountNumber));
        
        if (receiptsWithThisDebtor.length > 0) {
          skipped++;
          skippedNames.push(`${customer.displayName} (${receiptsWithThisDebtor.length} Rechnungen)`);
          continue;
        }
        
        await tx.delete(dunningRules).where(eq(dunningRules.customerId, customer.id));
        await tx.delete(portalUserCustomers).where(eq(portalUserCustomers.customerId, customer.id));
        await tx.delete(portalCustomers).where(eq(portalCustomers.id, customer.id));
        deleted++;
      }
      
      return { deleted, skipped, skippedNames: skippedNames.slice(0, 10) };
    });
  }

  // Counterparty mappings
  async getCounterpartyMappings(): Promise<CounterpartyMapping[]> {
    return db.select().from(counterpartyMappings).orderBy(counterpartyMappings.counterpartyName);
  }

  async getCounterpartyMapping(counterpartyName: string): Promise<CounterpartyMapping | undefined> {
    const [mapping] = await db
      .select()
      .from(counterpartyMappings)
      .where(eq(counterpartyMappings.counterpartyName, counterpartyName));
    return mapping;
  }

  async createCounterpartyMapping(mapping: InsertCounterpartyMapping): Promise<CounterpartyMapping> {
    const [created] = await db
      .insert(counterpartyMappings)
      .values(mapping)
      .onConflictDoUpdate({
        target: counterpartyMappings.counterpartyName,
        set: { debtorPostingaccountNumber: mapping.debtorPostingaccountNumber },
      })
      .returning();
    return created;
  }

  async deleteCounterpartyMapping(id: string): Promise<boolean> {
    const result = await db.delete(counterpartyMappings).where(eq(counterpartyMappings.id, id)).returning();
    return result.length > 0;
  }

  async getUnmatchedCounterparties(): Promise<{ counterpartyName: string; count: number }[]> {
    const receipts = await db
      .select()
      .from(bhbReceiptsCache)
      .where(eq(bhbReceiptsCache.debtorPostingaccountNumber, 0));
    
    const exceptions = await db.select().from(counterpartyExceptions);
    const ignoredNames = new Set(exceptions.map((e) => e.counterpartyName));
    
    const countMap = new Map<string, number>();
    for (const receipt of receipts) {
      const name = (receipt.rawJson as any)?.counterparty;
      if (name && !ignoredNames.has(name)) {
        countMap.set(name, (countMap.get(name) || 0) + 1);
      }
    }
    
    return Array.from(countMap.entries())
      .map(([counterpartyName, count]) => ({ counterpartyName, count }))
      .sort((a, b) => b.count - a.count);
  }
  
  async getCounterpartyExceptions(): Promise<{ id: string; counterpartyName: string; status: string; note: string | null }[]> {
    return db.select().from(counterpartyExceptions).orderBy(counterpartyExceptions.counterpartyName);
  }
  
  async createCounterpartyException(counterpartyName: string, status: string = "ignored", note?: string): Promise<{ id: string; counterpartyName: string; status: string }> {
    const [created] = await db
      .insert(counterpartyExceptions)
      .values({ counterpartyName, status, note })
      .returning();
    return created;
  }
  
  async deleteCounterpartyException(id: string): Promise<boolean> {
    const result = await db.delete(counterpartyExceptions).where(eq(counterpartyExceptions.id, id));
    return (result.rowCount ?? 0) > 0;
  }
  
  // Dunning email templates
  async getDunningEmailTemplates(): Promise<DunningEmailTemplate[]> {
    return db.select().from(dunningEmailTemplates).orderBy(dunningEmailTemplates.stage, dunningEmailTemplates.name);
  }
  
  async getDunningEmailTemplate(id: string): Promise<DunningEmailTemplate | undefined> {
    const [template] = await db.select().from(dunningEmailTemplates).where(eq(dunningEmailTemplates.id, id));
    return template;
  }
  
  async getDunningEmailTemplatesByStage(stage: string): Promise<DunningEmailTemplate[]> {
    return db
      .select()
      .from(dunningEmailTemplates)
      .where(and(eq(dunningEmailTemplates.stage, stage), eq(dunningEmailTemplates.isActive, true)))
      .orderBy(desc(dunningEmailTemplates.isDefault), dunningEmailTemplates.name);
  }
  
  async createDunningEmailTemplate(template: InsertDunningEmailTemplate): Promise<DunningEmailTemplate> {
    const [created] = await db.insert(dunningEmailTemplates).values(template).returning();
    return created;
  }
  
  async updateDunningEmailTemplate(id: string, template: Partial<InsertDunningEmailTemplate>): Promise<DunningEmailTemplate | undefined> {
    const [updated] = await db
      .update(dunningEmailTemplates)
      .set({ ...template, updatedAt: new Date() })
      .where(eq(dunningEmailTemplates.id, id))
      .returning();
    return updated;
  }
  
  async deleteDunningEmailTemplate(id: string): Promise<boolean> {
    const result = await db.delete(dunningEmailTemplates).where(eq(dunningEmailTemplates.id, id));
    return (result.rowCount ?? 0) > 0;
  }
  
  // Dunning events for customer
  async getDunningEventsForCustomer(customerId: string): Promise<DunningEvent[]> {
    return db
      .select()
      .from(dunningEvents)
      .where(eq(dunningEvents.customerId, customerId))
      .orderBy(desc(dunningEvents.createdAt));
  }
  
  async createDunningEventForCustomer(event: Omit<InsertDunningEvent, "receiptId"> & { customerId: string }): Promise<DunningEvent> {
    const [created] = await db.insert(dunningEvents).values(event).returning();
    return created;
  }
  
  async getCustomerOpenInvoiceStats(): Promise<Map<number, { count: number; totalOpen: number; overdueCount: number }>> {
    const today = new Date();
    const defaultPaymentTermDays = 14;
    
    const receipts = await db
      .select()
      .from(bhbReceiptsCache)
      .where(eq(bhbReceiptsCache.paymentStatus, "unpaid"));
    
    const statsMap = new Map<number, { count: number; totalOpen: number; overdueCount: number }>();
    
    for (const receipt of receipts) {
      if (!receipt.debtorPostingaccountNumber) continue;
      
      const existing = statsMap.get(receipt.debtorPostingaccountNumber) || { count: 0, totalOpen: 0, overdueCount: 0 };
      const amountOpen = parseFloat(receipt.amountOpen?.toString() || "0");
      
      existing.count++;
      existing.totalOpen += amountOpen;
      
      let effectiveDueDate: Date;
      if (receipt.dueDate) {
        effectiveDueDate = new Date(receipt.dueDate);
      } else if (receipt.receiptDate) {
        effectiveDueDate = new Date(receipt.receiptDate);
        effectiveDueDate.setDate(effectiveDueDate.getDate() + defaultPaymentTermDays);
      } else {
        effectiveDueDate = new Date();
      }
      
      // Only count as overdue if there's still an open amount AND past due date
      if (effectiveDueDate < today && amountOpen > 0) {
        existing.overdueCount++;
      }
      
      statsMap.set(receipt.debtorPostingaccountNumber, existing);
    }
    
    return statsMap;
  }
  
  // Branding configuration
  async getBrandingConfig(): Promise<BrandingConfig> {
    const rows = await db.select().from(brandingConfig);
    const config: Record<string, string | null> = {};
    for (const row of rows) {
      config[row.key] = row.value;
    }
    return {
      companyName: config.companyName || "Kundenportal",
      companyTagline: config.companyTagline || "Rechnungen & Zahlungen",
      logoUrl: config.logoUrl || null,
      faviconUrl: config.faviconUrl || null,
      primaryColor: config.primaryColor || "#16a34a",
      primaryForeground: config.primaryForeground || "#ffffff",
      accentColor: config.accentColor || "#f0fdf4",
      sidebarColor: config.sidebarColor || "#f8fafc",
      backgroundColor: config.backgroundColor || "#ffffff",
      cardColor: config.cardColor || "#ffffff",
      supportEmail: config.supportEmail || null,
      supportPhone: config.supportPhone || null,
      footerText: config.footerText || null,
      customCss: config.customCss || null,
    };
  }
  
  async setBrandingConfig(config: Partial<BrandingConfig>): Promise<BrandingConfig> {
    for (const [key, value] of Object.entries(config)) {
      if (value !== undefined) {
        await this.setBrandingConfigValue(key, value === null ? "" : String(value), "branding");
      }
    }
    return this.getBrandingConfig();
  }
  
  async getBrandingConfigValue(key: string): Promise<string | null> {
    const [row] = await db.select().from(brandingConfig).where(eq(brandingConfig.key, key));
    return row?.value ?? null;
  }
  
  async setBrandingConfigValue(key: string, value: string, category: string = "branding"): Promise<BrandingConfigRow> {
    const existing = await db.select().from(brandingConfig).where(eq(brandingConfig.key, key));
    if (existing.length > 0) {
      const [updated] = await db
        .update(brandingConfig)
        .set({ value, category, updatedAt: new Date() })
        .where(eq(brandingConfig.key, key))
        .returning();
      return updated;
    } else {
      const [created] = await db
        .insert(brandingConfig)
        .values({ key, value, category })
        .returning();
      return created;
    }
  }
  
  // Sync logs
  async getSyncLogs(limit: number = 50): Promise<SyncLog[]> {
    return db
      .select()
      .from(syncLogs)
      .orderBy(desc(syncLogs.startedAt))
      .limit(limit);
  }
  
  async getSyncLog(id: string): Promise<SyncLog | undefined> {
    const [log] = await db.select().from(syncLogs).where(eq(syncLogs.id, id));
    return log;
  }
  
  async createSyncLog(log: InsertSyncLog): Promise<SyncLog> {
    const [created] = await db.insert(syncLogs).values(log).returning();
    return created;
  }
  
  async updateSyncLog(id: string, data: Partial<InsertSyncLog>): Promise<SyncLog | undefined> {
    const [updated] = await db
      .update(syncLogs)
      .set(data)
      .where(eq(syncLogs.id, id))
      .returning();
    return updated;
  }
  
  async getLastSyncLog(entityType?: string): Promise<SyncLog | undefined> {
    let query = db.select().from(syncLogs).orderBy(desc(syncLogs.startedAt)).limit(1);
    if (entityType) {
      const [log] = await db
        .select()
        .from(syncLogs)
        .where(eq(syncLogs.entityType, entityType))
        .orderBy(desc(syncLogs.startedAt))
        .limit(1);
      return log;
    }
    const [log] = await query;
    return log;
  }
}

export const storage = new DatabaseStorage();
