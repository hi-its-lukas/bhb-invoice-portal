Rolle: Du bist ein Senior DevOps Engineer und Fullstack Developer.

Aufgabe: Bitte refactore mein bestehendes Projekt (bhb-invoice-portal), um einen robusten "Self-Update"-Mechanismus mittels eines Reverse-Proxy-Patterns zu implementieren. Ziel ist es, dass die Anwendung sich selbst via Docker Compose aktualisieren kann, während dem Nutzer eine Wartungsseite angezeigt wird.

Bitte führe die folgenden 4 Schritte durch:

Schritt 1: Erstelle den Updater-Proxy Service
Erstelle im Root-Verzeichnis einen neuen Ordner updater mit folgenden Dateien:

updater/Dockerfile:

Basis: node:18-alpine.

Installiere docker-cli und docker-cli-compose-plugin (via apk), damit der Container Docker-Befehle ausführen kann.

Arbeitsverzeichnis /app, kopiere package.json und Source, installiere Dependencies.

updater/package.json:

Dependencies: express, http-proxy-middleware.

updater/maintenance.html:

Erstelle eine Wartungsseite im Stil meiner App (nutze System Fonts, sauberes Design).

Text: "Update wird installiert... Das System startet in Kürze neu."

Logik (Script): Polle alle 1 Sekunde den Endpoint /api/health. Wenn er mit Status 200 antwortet, führe window.location.reload() aus.

updater/index.js:

Erstelle einen Express Server.

Lese PROXY_PORT (Default: 5000) und TARGET_URL (Default: http://app:5000) aus den ENV-Vars.

Nutze http-proxy-middleware, um Requests standardmäßig an TARGET_URL weiterzuleiten.

Implementiere Route POST /api/system/start-update:

Setze eine Variable isMaintenance = true.

Sende sofort { "message": "Update started" } zurück.

Führe asynchron folgende Shell-Befehle im Pfad /project aus:

docker compose pull app

docker compose up -d --force-recreate app

Nach den Befehlen: Polle TARGET_URL + /api/health bis die App wieder da ist, dann setze isMaintenance = false.

Middleware-Logik: Wenn isMaintenance true ist:

Sende bei Requests, die HTML akzeptieren (Browser), die maintenance.html.

Sende bei API-Requests Status 503.

Implementiere Endpoint /api/updater/health, der einfach "OK" sendet.

Schritt 2: Update docker-compose.yml
Passe die docker-compose.yml wie folgt an:

Füge einen Service proxy hinzu:

Build context: ./updater.

Ports: "${PORT:-5000}:${PORT:-5000}" (Nimmt PORT aus .env).

Volumes:

/var/run/docker.sock:/var/run/docker.sock

./:/project (Projekt-Root mounten).

Environment: PROXY_PORT=${PORT:-5000}, TARGET_URL=http://app:5000.

Depends on: app.

Ändere den Service app:

Entferne ports.

Füge expose: - "5000" hinzu.

Setze Environment PORT=5000.

Schritt 3: Backend Healthcheck
Bearbeite server/index.ts:

Füge ganz oben (vor den anderen Routen) einen Endpoint app.get('/api/health', ...) hinzu, der Status 200 und "OK" sendet. Dies wird vom Proxy benötigt, um zu wissen, wann die App gestartet ist.

Schritt 4: Frontend UI ("Update" Button)
Bearbeite client/src/pages/settings/index.tsx:

Füge eine neue Sektion oder Card für "System Update" hinzu.

Implementiere eine useMutation, die POST /api/system/start-update aufruft.

UX-Wichtig: Füge einen React-State isUpdating hinzu. Wenn der Button geklickt wird (oder onMutate), setze isUpdating = true.

Zeige bei isUpdating ein Fullscreen-Overlay (z.B. mit Backdrop-Blur und Spinner) mit dem Text "Update wird gestartet...".

Im onSuccess der Mutation: Warte 1-2 Sekunden (Timeout) und erzwinge dann window.location.reload(). Dies führt den Nutzer auf die maintenance.html des Proxys.

Bitte setze diese Änderungen jetzt um und achte darauf, dass bestehende Funktionen nicht beeinträchtigt werden.