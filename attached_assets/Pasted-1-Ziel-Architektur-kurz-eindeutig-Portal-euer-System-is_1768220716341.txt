1) Ziel-Architektur (kurz & eindeutig)

Portal (euer System) ist “Source of Truth” für:

Login/Kunden-Zuordnung

Mahnstufe, Verzugszinsen, Mahngebühren

Mailversand / Reminder / Mahnungen

Pro-Debitor Regeln

BHB ist “Source of Truth” für:

Belege/Rechnungen (Receipts) + Zahlstatus

Debitorenstammdaten (Debitor-Konten)

BHB API Eckdaten:

API Host/BasePath: https://webapp.buchhaltungsbutler.de/api/v1

2) BHB-Endpoints, die wir fürs Portal brauchen
2.1 Rechnungen/OPs (Ausgangsbelege)

Liste ziehen:

POST /receipts/get
Pflichtfelder:

api_key (Mandant)

list_direction: outbound (Ausgangsbelege)

Wichtig fürs OP-Portal:

payment_status: unpaid (nur offene)

Pagination: limit max 500 + offset

Sortierung möglich (date/amount/invoicenumber/…)

Fälligkeitsfilter: due_date existiert als Filterparameter

Einzelbeleg + PDF:

POST /receipts/get/id_by_customer mit get_file=true → File als base64 (PDF/ZUGFeRD/xRechnung)

2.2 Debitorenstamm (Debitorennummern / posting accounts)

Debitor-Konten existieren als postingaccount_number (Debitorennummer). Das sieht man z.B. bei:

POST /settings/update/debtor (Pflicht: postingaccount_number)

POST /settings/add-batch/debtors (Batch-Anlage)

Zusätzlich gibt es einen generischen “Postingaccounts get” Endpoint (in der Spec direkt vor update/debtor), der u.a. Filter wie exclude_debtors/exclude_creditors etc. kennt (damit holst du dir die Debitor-Liste ins Portal).

2.3 Wichtig: Debitor-Zuordnung an Rechnungen

Beim Anlegen eines Belegs kann BHB direkt den Debitor zuordnen:

/receipts/add Parameter creditor_debtor = Postingaccount_number (z.B. 70001)

Für “bestehende Rechnungen aus BHB” ist entscheidend, ob receipts/get oder receipts/get/id_by_customer die Debitorennummer im Receipt-Objekt zurückliefert. Das klären wir im Code beim ersten echten API-Response (siehe Sprint 2/3 unten).
Plan B ist trotzdem sauber: über Debitor-Name/CustomerNumber (kommt aus Debitor-Stamm) – aber mit Debitorennummern ist Plan A fast immer möglich.

3) Datenmodell im Portal (Debitorennummer als Primärschlüssel)
Tabellen (Minimum)

portal_customers

id

debtor_postingaccount_number (int, unique) ← DAS ist eure Debitorennummer

display_name

email_contact (für Mahnungen)

is_active

portal_users

Login + Rollen

portal_user_customers

user ↔ debtor mapping (ein User kann mehrere Debitoren sehen)

bhb_receipts_cache

id

id_by_customer (string/unique) ← wichtig für /receipts/get/id_by_customer

debtor_postingaccount_number (int, indexed)

invoice_number

receipt_date

due_date

amount_total

payment_status (paid/unpaid)

raw_json

last_synced_at

dunning_rules (pro Debitor)

grace days, interest mode, stages json

dunning_events

pro Rechnung/Stufe: wann gesendet, status, error

4) Replit-Abarbeitungsplan (extrem konkret, sprintweise)
Sprint 0 – Repo/Grundgerüst (Replit + Docker)

Ergebnis: App läuft lokal + docker-compose läuft.

Next.js (Fullstack) ODER Fastify + React (du hattest Replit – Next ist am schnellsten)

Prisma + Postgres (in Docker)

Secrets:

BHB_BASE_URL=https://webapp.buchhaltungsbutler.de/api/v1

BHB_API_CLIENT, BHB_API_SECRET, BHB_API_KEY

SMTP creds

Sprint 1 – Auth + Mandanten-/Debitor-Setup

Ergebnis: Admin kann Debitoren im Portal anlegen und User zuordnen.

Admin UI:

Debitor anlegen: debtor_postingaccount_number (Pflicht)

Kontakt-E-Mail + Mahnprofil auswählen

Portal-User anlegen und Debitoren zuordnen

Sprint 2 – BHB Client + “Schema Probe”

Ergebnis: Ihr wisst 100% welche Receipt-Felder BHB liefert (inkl. Debitorenbezug).

Implementiere BHB Client:

Basic Auth + JSON Body Requests

Baue Admin Button “Test receipts/get (outbound/unpaid)”

Call: POST /receipts/get mit list_direction=outbound, payment_status=unpaid, limit=10

Logge roh:

erstes Receipt-Objekt vollständig (in server logs)

Ziel: herausfinden:

welches Feld enthält Debitorennummer oder ein Link auf Debitor?

falls nicht: nächste Stufe → /receipts/get/id_by_customer für 1–2 Belege ziehen und prüfen

Sprint 3 – Sync-Job (Cache) + Portal Rechnungsliste

Ergebnis: Kunde sieht Rechnungen/OPs im Portal (nur seine Debitorennummer).

Scheduler (cron alle 30–60 min):

POST /receipts/get outbound (und je nach Wunsch paid+unpaid)

pagination via offset

upsert into bhb_receipts_cache

Zugriffskontrolle:

Portal zeigt nur rows mit debtor_postingaccount_number die dem User zugeordnet sind

Sprint 4 – PDF Download

Ergebnis: Kunde kann Rechnung als PDF laden.

Endpoint: POST /receipts/get/id_by_customer mit get_file=true

Datei (base64) in Response umwandeln und als Download streamen

Optional: caching der PDF base64 (mit TTL) – muss nicht sofort

Sprint 5 – OP/Überfällig + Verzugszinsen

Ergebnis: Offene + überfällige + Zinsen “bis heute” pro Rechnung.

“Überfällig”:

today > due_date AND payment_status=unpaid

Zinsberechnung:

pro Debitor konfigurierbar (fixed rate oder rechtlicher Satz)

tagesgenau: open_amount * rate * days/365

UI:

Rechnungsliste: Mahnstufe, Tage überfällig, Zinsen bis heute

Sprint 6 – Mahnstufen Engine (pro Debitor konfigurierbar)

Ergebnis: Mahnstufe wird sauber berechnet und gespeichert.

Debitor-Regel: stages JSON:

Erinnerung nach X Tagen

Mahnung 1/2/3 nach Y/Z/… Tagen

optionale Gebühr je Stufe

Engine:

berechnet “welche Stufe wäre heute fällig”

prüft in dunning_events, ob diese Stufe schon gesendet wurde

Sprint 7 – Automatische Zahlungserinnerungen/Mahnungen (E-Mail)

Ergebnis: System verschickt automatisch, protokolliert sauber.

Daily job (z.B. 07:00):

alle unpaid/outbound receipts iterieren

pro Debitor Regeln anwenden

Mail senden, Event schreiben

Mail Templates:

Reminder (freundlich)

Mahnung 1/2/3 (strenger, inkl. Zinsen/Gebühren)

Optional: “Kunde klickt Portal-Link → sieht Rechnung + Betrag + Zinsen”

Sprint 8 – Debitoren Sync aus BHB (optional, aber sinnvoll)

Ergebnis: Debitor-Stammdaten automatisch im Portal aktuell.

“Postingaccounts get” Endpoint nutzen (Debitoren nicht excluden)

Debitoren als portal_customers upserten

Admin kann danach nur noch Portal-User zuordnen

Sprint 9 – Hardening / Betrieb

Rate limiting intern (BHB + Portal)

Audit logs

SMTP Bounce/Fehler Dashboard

Docker compose prod: reverse proxy + TLS

5) Wichtigste Entscheidung (mit Debitorennummern)

Du nutzt im Portal ausschließlich:

debtor_postingaccount_number als “Tenant Key”

Regeln/Emails/Views hängen alle daran

Rechnungen werden beim Sync dieser Debitorennummer zugeordnet

Wenn BHB Receipts die Debitorennummer nicht direkt liefern sollte:

dann holen wir sie über:

Detail-Endpunkt pro Receipt (/receipts/get/id_by_customer)

oder über Debitor-Stamm + Receipt-Felder (Fallback)
Aber das klärt Sprint 2 automatisch, ohne Rätselraten.